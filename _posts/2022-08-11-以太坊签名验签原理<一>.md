---
date: 2022-08-11
layout: post
title: 以太坊签名验签原理<一>
description: 解析以太坊签名背后的数学原理
image: https://images.unsplash.com/photo-1523296004693-49fb425078b4?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjcwOTV9&s=9c830e7f29e234f61b2acc67301fb10e
optimized_image: https://images.unsplash.com/photo-1523296004693-49fb425078b4?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjcwOTV9&s=9c830e7f29e234f61b2acc67301fb10e
subtitle: 
category: STUDY
tags:
 - ethereum
author: aventusc
---
# 以太坊签名验签原理<一>
## 1. 签名原理
*引言：*
*签名需要实现的输入输出转变有：*
- *输入：*

  *一个输入消息、一个私钥和一个（通常情况下是秘密的）随机数，就可以得到一串数字作为输出值，也就是签名。*

- *输出：*

  *使用另一个数学公式可以进行反向计算，在不知道私钥和随机数的情况下进行验证。*

能实现上述输入输出转换过程的有很多种算法，比如常见的RSA。但以太坊使用的是`椭圆曲线数字签名算法(ECDSA)`。

需要注意的是：ECDSA知识签名算法。与 RSA  不同，这种算法不能用于加密。以太坊采用的是 `secp256k1`曲线。

### 1.1 ECDSA签名过程

ECDSA 签名由两个数字（**整数**）组成：`r` 和` s`。以太坊还引入了额外的变量 `v`（**恢复标识符**）。签名可以表示成 `{r, s, v}`。

正如引言所说，在创建签名时，你要先准备好一条待签署的消息和用来签署该消息的`私钥（d）`。简化后的签名流程如下：

1. 对待签署消息进行哈希计算，得到`哈希值（e）`。
2. 生成一个安全的`随机数 k`。
3. 将` k `乘以椭圆曲线的常量 `G`，来计算椭圆曲线上的点`（x, y）`。
4. 计算 `r = x mod n`。如果 r 等于 0，请返回步骤 2 。
5. 计算 `s = k(e + rd) mod n`。如果 s 等于 0，请返回步骤 2。

在以太坊上，通常使用` Keccak256("\x19Ethereum Signed Message:\n32" + Keccak256(message))`来计算哈希值。这样可以确保该签名不能在以太坊之外使用。

## 2. 签名验证

### 2.1 ECDSA签名验证

为了验证消息，我们需要掌握原始消息、使用私钥签署消息的地址，以及 {r, s, v} 签名本身。版本号就是使用的某个版本号。以符合 JSON-RPC 方法personal_sign 方法，因此需要指明版本号（“2”）。

简化后的`公钥恢复流程`如下：

1. 计算消息的`哈希值（e）`。
2. 计算椭圆曲线上的点 `R = (x, y)`，其中 x 是 r（v = 27），或 r + n（v = 28）。
3. 计算` u = -zr mod n` 和 `u = sr mod n`。
4. 计算点` Q = (x, y) = u × G + u × R`。(G为椭圆曲线常量)

**Q** 是地址用来签名的私钥所对应的**公钥**。我们可以通过公钥计算出一个地址，并检查该地址是否与已提供地址相符。如果相符，则签名有效。

### 2.2 恢复标识符（“v”）

v 是签名的**最后一个字节**，而且不是 27 (0x1b) 就是 28 (0x1c)。恢复标识符非常重要，因为我们使用的是椭圆曲线算法，仅凭`r `和` s `可计算出曲线上的多个点，因此会恢复出两个不同的公钥（及其对应地址）。`v `会告诉我们应该使用这些点中的哪一个。

在大多数实现中，v 在内部只是 0 或 1，而 27 是在签署比特币消息时加上的任意数。以太坊也接受了这一点。

从 EIP-155 开始，我们还使用链 ID 来计算 v 值。这可以防止跨链重放攻击：以太坊上签署的交易无法在以太坊经典上使用，反之亦然。目前，恢复标识符只用来签署交易而非消息。

### 2.3 签名消息的标准化

关于如何为签名消息定义标准结构，人们提出了很多种提议。目前为止，还没有一个提议最终确定下来。最初由 Geth 实现的 personal_sign 格式依然是最常见的。尽管如此，有一些提议非常有趣。

先来简单介绍下目前创建签名所采用的方式：

```
"\x19Ethereum Signed Message:\n" + length(message) + message
```

消息通常会预先进行哈希计算，因此长度会固定在 32 个字节：

```
"\x19Ethereum Signed Message:\n32" + Keccak256(message)
```

完整的消息（包括前缀）会再经历一次哈希计算，然后用私钥对哈希值签名。这种方式适用于所有权证明，但是在其它情况下可能会出现问题。

## 3. 签署交易

目前为止，我们主要讨论了针对消息的签名。就像消息一样，交易在发送前也需要签名。如果你使用 Ledger 和 Trezor 之类的硬件钱包，签名过程会在硬件内部发生。如果使用私钥（或 keysotre 文件、助记词），可以直接在 MyCrypto 上完成签名。签署交易所使用的方法与签署消息非常相似，只不过交易的编码方式略有不同。

要签署的交易先用 `RLP 编码`方式**编码**，包含了所有交易参数`（nonce、gas price、gas limit、to、value、data）`和`签名（v, r, s）`

签过名的交易的第一组字节包含 RLP 编码后的交易参数，最后一组字节包含签名 {r, s, v}。

我们可以通过以下方式对签名交易进行**编码**：

1. **交易参数**：RLP(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)。
2. 使用 **Keccak256 算法**来计算经过 RLP 编码的未签署交易的哈希值。
3. 按照上文讲述的步骤，通过 **ECDSA 算法**，使用私钥签署哈希值。对已签名的交易进行编码：RLP(nonce, gasPrice, gasLimit, to, value, data, v, r, s)。

将经过 RLP 编码的交易数据解码后，我们又可以得到原始交易参数和签名。

请注意，**链 ID** 是被编码到签名的` v `参数中的，因此我们**不会**将链 ID 本身包含在最终的签名交易数据中。我们也不会提供任何发送方地址，**因为地址可以通过签名恢复**。这就是以太坊网络内部用来验证交易的方式。

*具体有关用交易恢复地址的实例，可以参考我写的那篇capture the ether攻略*



本文参考：

[https://mirror.xyz/0x9B5b7b8290c23dD619ceaC1ebcCBad3661786f3a/jU9qUqkhF5PAG_TXIB0Mb481-cGaaaaTAvAF8FaHt40](https://mirror.xyz/0x9B5b7b8290c23dD619ceaC1ebcCBad3661786f3a/jU9qUqkhF5PAG_TXIB0Mb481-cGaaaaTAvAF8FaHt40)





