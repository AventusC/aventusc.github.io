---
date: 2022-08-29
layout: post
title: rust入门篇-流程控制与模式匹配
description: 介绍流程控制、模式匹配和方法
image: https://user-images.githubusercontent.com/90261136/189070351-11b9a3d4-e7aa-4fd5-8a6b-31ccba5c53ac.jpg
optimized_image: https://user-images.githubusercontent.com/90261136/189070351-11b9a3d4-e7aa-4fd5-8a6b-31ccba5c53ac.jpg
subtitle:
category: STUDY
tags:
 - STUDY
 - Rust
author: aventusc
---

# 流程控制、模式匹配和方法

## 流程控制

### if...else...

*大体上是和其他语言的用法都一致的，而区别如下：*

先看下面代码：

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
println!("The value of number is: {}", number);

```

以上代码有以下几点要注意：

- if 内部的语句块是**表达式**，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5
- 用 if 来赋值时，要保证**每个分支返回的类型一样**(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错

### 循环控制

*在 Rust 语言中有三种循环方式：for、while 和 loop，其中 for 循环是 Rust 循环王冠上的明珠。*

#### for循环

主要就在于 for 和 in 的联动，语义表达如下：

```rust
for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
```

注意，使用 for 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 container 的引用）。如果不使用引用的话，所有权会被转移（move）到 for 语句块中，后面就无法再使用这个集合了)：

```rust
for item in &container {
  // ...
}
```

对于实现了 copy 特征的数组(例如 [i32; 10] )而言， for item in arr 并不会把 arr 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 arr 。

总结如下：

| 使用方法                    | 等价使用方式                                    | 所有权     |
| --------------------------- | ----------------------------------------------- | ---------- |
| for item in collection      | for item in IntoIterator::into_iter(collection) | 转移所有权 |
| for item in &collection     | for item in collection.iter()                   | 不可变借用 |
| for item in &mut collection | for item in collection.iter_mut()               | 可变借用   |

有同学可能会想到，如果我们想用 for 循环控制某个过程执行 10 次，但是又不想单独声明一个变量来控制这个流程，该怎么写？

```rust
for _ in 0..10 {
  // ...
}
```

可以用 _ 来替代 i 用于 for 循环中，在 Rust 中 _ 的含义是忽略该值或者类型的意思，如果不使用 _，那么编译器会给你一个 变量未使用的 的警告。

#### continue和break

*与其他语言的用法一致，这里没什么好多说的*

#### while

*用法与其他的语言一致*

while循环体内的语句也就是正常的语句，不是结构体

#### loop

loop是一个无限循环，因此要谨慎使用，它必须和break一起搭配使用。

这里有几点值得注意：

- break 可以单独使用，也可以带一个返回值，有些类似 return
- loop 是一个表达式，因此可以返回一个值



## 模式匹配

*整个模式的操作方式，其实是很类似于其他语言的switch操作*

### match&if let

#### match

match的通用格式：

```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```

match 后紧跟着的是一个表达式，跟 if 很像，但是 if 后的表达式必须是一个**布尔值**，而 match 后的表达式返回值可以是**任意类型**，只要能跟后面的分支中的模式匹配起来即可

接下来是 match 的分支。一个分支有两个部分：一个模式和针对该模式的处理代码。模式与表达式之间用运算符`=>`分隔开，这里的代码就仅仅是表达式 1，不同分支之间使用逗号分隔。

重要提示：

- match本身也是一个表达式，所以可以用它来赋值。例如：

  ```rust
  enum IpAddr {
     Ipv4,
     Ipv6,
  }
  
  fn main() {
      let ip1 = IpAddr::Ipv6;
      let ip_str = match ip1 {
          IpAddr::Ipv4 => "127.0.0.1",
          _ => "::1",
      };
  
      println!("{}", ip_str);
  }
  ```

  因为这里匹配到 _ 分支，所以将 "::1" 赋值给了 ip_str。

- match的匹配必须穷尽所有情况。

- `_`通配符：

  可以代替那些不想列出来的匹配情况

#### if let匹配

有时会遇到**只有一个模式的值需要被处理，其它值直接忽略的场景**，如果用 match 来处理就要写成下面这样：



```rust
let v = Some(3u8);
match v {
    Some(3) => println!("three"),
    _ => (),
}
```

我们只想要对 Some(3) 模式进行匹配, 不想处理任何其他 Some<u8> 值或 None 值。但是为了满足 match 表达式（穷尽性）的要求，写代码时必须在处理完这唯一的成员后加上 _ => ()，这样会增加不少无用的代码。

杀鸡焉用牛刀，可以用 if let 的方式来实现：

```rust
if let Some(3) = v {
    println!("three");
}
```

这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：**当你只要匹配一个条件，且忽略其他条件时就用 if let ，否则都用 match。**

#### matches!宏

Rust 标准库中提供了一个非常实用的宏：matches!，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 true or false。



## 方法Method

*类似于其他面向对象语言比如Java中方法的使用*，*不过与其它语言 class 跟方法的联动使用不同（这里可能要修改下），Rust 的方法往往跟结构体、枚举、特征(Trait)一起使用，特征将在后面几章进行介绍。*

### 定义方法

- 使用关键字`impl`来定义方法

  例如：

  ```rust
  #![allow(unused)]
  fn main() {
  struct Circle {
      x: f64,
      y: f64,
      radius: f64,
  }
  
  impl Circle {
      // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字
      // 这种方法往往用于初始化当前结构体的实例
      fn new(x: f64, y: f64, radius: f64) -> Circle {
          Circle {
              x: x,
              y: y,
              radius: radius,
          }
      }
  
      // Circle的方法，&self表示借用当前的Circle结构体
      fn area(&self) -> f64 {
          std::f64::consts::PI * (self.radius * self.radius)
      }
  }
  }
  ```

- rust中方法定义与其他语言的方法定义的对比：

  ![image-20220829213032412](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220829213032412.png)

可以看出，其它语言中所有定义都在 class 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。

- rust中，方法名可以和结构体的字段名相同

- 在 C/C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 `object` 是一个指针，那么 `object->something()` 和 `(*object).something()` 是一样的。

  Rust 并没有一个与 `->` 等效的运算符；相反，Rust 有一个叫 **自动引用和解引用**的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。

  他是这样工作的：当使用 `object.something()` 调用方法时，Rust 会自动为 `object` 添加 `&`、`&mut` 或 `*` 以便使 `object` 与方法签名匹配。

  （即：rust中仅需要`.`一个运算符即可完成对象调用方法这件事）

### 关联函数

这种定义在 `impl` 中且没有 `self` 的函数被称之为**关联函数**： 因为它没有 `self`，不能用 `f.read()` 的形式调用，因此它是一个函数而不是方法，它又在`impl` 中，与结构体紧密关联，因此称为关联函数。

例如：

```rust
impl Rectangle {
    fn new(w: u32, h: u32) -> Rectangle {
        Rectangle { width: w, height: h }
    }
}
```

Rust 中有一个约定俗成的规则，使用` new` 来作为**构造器的名称**，出于设计上的考虑，Rust **特地没有用 `new` 作为关键字**。

因为是函数，所以不能用 `.` 的方式来调用，我们需要用 `::` 来调用，例如 `let sq = Rectangle::new(3, 3);`。这个方法位于结构体的命名空间中：`::` 语法用于关联函数和模块创建的命名空间。

*即：第一个参数是`self`或者`&self`的就是方法，否则就是关联函数，这种差异直接体现在调用方法上：
关联函数：可以独立调用，无需类型的实例，因为毕竟本身就是个函数。但由于关联于某个类型，所以得使用类似`String::from()`的方式；
方法：无法独立调用，必须先有类型的实例，再有方法。比如f.read()等。*

### 多个impl定义

rust允许我们为一个结构体定义多个impl，目的是提供更多的灵活性和代码组织性。





参考：

《rust圣经》：[https://course.rs/about-book.html](https://course.rs/about-book.html)

