---
date: 2022-08-27
layout: post
title: rust学习记录01
description: 基础类型，所有权和引用
image: https://user-images.githubusercontent.com/90261136/189068727-6352a806-e9e4-4955-a30b-df321d5c84a7.jpg
optimized_image: https://user-images.githubusercontent.com/90261136/189068727-6352a806-e9e4-4955-a30b-df321d5c84a7.jpg
subtitle:
category: STUDY
tags:
 - STUDY
 - Rust
author: aventusc
---

# rust学习记录01_所有权与引用

*前言：*

*说一下，在已经有rust圣经这样很完美的教材的情况下，我为什么还要写rust学习记录？最主要的目的：将**我**在rust圣经中学到的**关键点**全都记录下来，虽然不一定很全面，但至少记录上来的部分都是重点！其次就是圣经上讲得虽好，但是知识点太多了，不方便查询，我单独写一篇总结就更有利于我后面快速学习的查漏补缺*

## 小知识合集

- *rust中**默认所有的字段都是私有的**，只对当前文件公开。*

- *类型之间的转换使用 `num as 数据类型`的方式来转换*

- rust整型默认使用`i32`

- rust浮点类型默认使用`f64`

- 能直接使用的数据都必须是存储在栈中

- 当使用RA插件时，在控制台输入`cargo run`即可自动根据需要来下载或引用依赖

- `fn_name::new()`的方式就可以创建一个对应的构造函数

- 一个切片引用占2个字大小的内存空间

  例如在 `x86-64` 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。

## 变量与常量

- 使用`let`关键字来**绑定**变量

  ```rust
  let name = "张三";
  ```

- 占位符只有`{}`，而没有`%d`和`$s`

- 使用下划线作为变量开头来忽略未使用的变量

  ```rust
  fn main() {
      let _x = 5;
      let y = 10;
  }
  ```

- 使用`const`关键字来声明常量，并且值类型也必须标注出来

  且Rust 常量的命名约定是**全部字母都使用大写**，并使用**下划线分隔单词**，另外对数字字面量**可插入下划线以提高可读性**

  ```rust
  const MAX_POINTS: u32 = 100_000;
  ```

*rust是一门强类型语言，并且为了保证安全性，因此**变量不会主动赋值**，即每一个基础类型的变量都需要我们声明并初始化之后才能使用。*

## 基本类型

### 数值类型

#### 整数类型

下表显示了 Rust 中的内置的整数类型：

| 长度           | 有符号类型 | 无符号类型 |
| -------------- | ---------- | ---------- |
| 8 位           | i8         | u8         |
| 16 位          | i16        | u16        |
| 32 位          | i32        | u32        |
| 64 位          | i64        | u64        |
| 128 位         | i128       | u128       |
| **视架构而定** | isize      | usize      |

类型定义的形式统一为：**有无符号 + 类型大小(位数)**。**无符号数**表示数字只能取正数，而**有符号**则表示数字既可以取正数又可以取负数。当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以**补码**形式存储。

每个**有符号类型**规定的数字范围是 -(2^n - 1) ~ 2^n - 1 - 1，其中 n 是该定义形式的**位长度**。因此 i8 可存储数字范围是 -(2^7) ~ 2^7 - 1，即 -128 ~ 127。**无符号类型**可以存储的数字范围是 0 ~ 2^n - 1，所以 u8 能够存储的数字为 0 ~ 2^8 - 1，即 0 ~ 255。

此外，isize 和 usize 类型取决于**程序运行的计算机 CPU 类型**： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。

rust语言的整数型相较于其他语言中整数型的不同之处有：

- 必须是**相同类型**才能进行运算

- Rust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的**字节数**，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数

- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数

- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型.

  rust中数值的初始化的三种方法：

  ```rust
  let num_arr = [
  	21.0,
  	21f32,
  	21.0_f32,
  	//这三种方法都是把21.0声明为f32，第一种由系统主动判定而已
  ]
  ```

一个综合案例：

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}

```

#### 浮点类型

- 默认浮点类型为：`f64`

- **避免**在浮点数上测试**相等性**

  *因为每个浮点数的值都是和整数值近似相等，当要求多个浮点数运算后的结果进行相等判断时就不能准确判断*

- 当结果在数学上可能存在**未定义**时，需要格外的小心

#### 位运算

*Rust的运算基本上和其他语言一样*

| 运算符  | 说明                                   |
| ------- | -------------------------------------- |
| & 位与  | 相同位置均为1时则为1，否则为0          |
| \| 位或 | 相同位置只要有1时则为1，否则为0        |
| ^ 异或  | 相同位置不相同则为1，相同则为0         |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0 |
| << 左移 | 所有位向左移动指定位数，右位补零       |
| >> 右移 | 所有位向右移动指定位数，左位补零       |

#### 序列（range）

*和python中的一样*

举个栗子：

```rust
#![allow(unused)]
fn main() {
for i in 1..=5 {
    println!("{}",i);
}
}
```

通常情况下序列是左闭右开`[)`，但上述情况因为最后使用了`=`符号，所以就变成了左闭右闭。

### ()是单元类型

单纯的`()`符号就是单元类型，它就会有返回值，即有()的就是表达式

### 语句与表达式

- 语句

  不能有返回值，比如使用let绑定变量的过程就是语句

- 表达式

  一个最后会返回结果的式子，其常在最后一行返回值。

  调用一个**函数是表达式**，因为会返回一个值，调用**宏**也是表达式，用**花括号**包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式

  最重要的特点就是：**表达式末尾不能有分号**！！！！！

  ***因为加上分号就变成语句了***

### 函数

- 函数签名：

  fn关键字、函数名、函数参数及其类型、返回值类型组成*函数签名*

- 声明函数的关键字为`fn`

  具体函数结构如下图所示：

  ![image-20220828140253612](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220828140253612.png)

- **函数本身就是表达式**，因为最后都会输出结果，而输出的结果要么为有值，要么为`单元类型()`(即代表无返回值)

- 函数返回值可以使用`return`关键字或者表达式进行返回

- 函数没有返回值，那么返回一个 ()
  通过 ; 结尾的表达式返回一个 ()

  例如下面的 report 函数会隐式返回一个 ()：

  ```rust
  use std::fmt::Debug;
  
  fn report<T: Debug>(item: T) {
    println!("{:?}", item);
  }
  ```

  与上面的函数返回值相同，但是下面的函数显式的返回了 ()：

  ```rust
  fn clear(text: &mut String) -> () {
    *text = String::from("");
  }
  ```

- 永不返回的发散函数` !`
  当用`!` 作函数返回类型的时候，表示该函数**永不返回**( diverge function )，特别地，这种语法往往用做会导致程序崩溃的函数：

  ```rust
   fn dead_end() -> ! {
      panic!("你已经到了穷途末路，崩溃吧！");
    }
  ```

  下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：

  ```rust
  fn forever() -> ! {
    loop {
      //...
    };
  }
  ```

## 所有权和借权

### 内存数据结构

栈和堆的核心目标就是为程序在**运行时**提供可供使用的内存空间。

#### 栈

- 后进先出

- 增加数据叫做进栈，移出数据则叫做出栈。

  因为上述的实现方式，栈中的**所有数据都必须占用已知且固定大小的内存空间**，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。

#### 堆

- 先进先出

- 与栈不同，对于**大小未知或者可能变化的数据**，我们需要将它存储在堆上。

  当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)。

  接着，**该指针**会被推入**栈**中，因为**指针的大小是已知且固定的**，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

#### 二者性能区别

- **写入方面**：

  入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

- **读取方面**：

  得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。

#### 所有权与堆栈

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。

### 所有权原则

三大基本原则：

- Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
- 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
- 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

### 函数传值与返回

将值传递给函数，一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样，下面的代码展示了所有权、作用域的规则：

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

你可以尝试在 `takes_ownership` 之后，再使用 `s`，看看如何报错？例如添加一行 `println!("在move进函数后继续使用s: {}",s);`。

## 引用与解引用

### 不可变引用与可变引用

#### 不可变引用

下面的代码，我们用 s1 的引用作为参数传递给 calculate_length 函数，而不是把 s1 的所有权转移给该函数：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
    
    println!("The length of '{}' is {}.", s1, len);

}
```

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

s和s1和堆中数据的引用关系如下图所示：

![image-20220828161713391](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220828161713391.png)



- 针对同一个变量，在相同作用域中：

  - 可以使用**多个不变指针**来引用

  - 但**绝对不可以**使用不变指针和可变指针同时存在，
  - 也**不可以**存在多个可变指针



### NLL

对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。



### 悬垂引用(Dangling References)

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器可以确保数据不会在其引用之前被释放，要想释放数据，必须先停止其引用的使用。



总的来说，借用规则如下：

同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
引用必须总是有效的

### [部分 move](https://zh.practice.rs/ownership/ownership.html#部分-move)

当解构一个变量时，可以同时使用 `move` 和引用模式绑定的方式。当这么做时，部分 `move` 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。

在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。

### ref的用法

`ref` 与 `&` 类似，可以用来获取一个值的引用，但是它们的用法有所不同。

例如：

```rust
let c = '中';
let r1 = &c;
let ref r2 = c;
assert_eq!(*r1,*r2);
```





参考：

《rust圣经》：[https://course.rs/about-book.html](https://course.rs/about-book.html)











